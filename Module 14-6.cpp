/*6. Проход змейкой (дополнительное задание)
Есть двумерный массив целых чисел размером 5 на 5 элементов.
Его надо инициализировать и отобразить на экране.
Особенность именно в способе этой инициализации.
Элементы должны быть инициализированы не последовательно, а змейкой:
в конце каждой строки мы должны не переходить к первому элементу следующей строки, а начать наоборот,
с последнего элемента и так далее. В конечном отображении массива числа должны быть упорядочены по возрастанию,
но змеевидно от строке к строке. Сама же последовательность чисел — это простое линейное возрастание от 0 до 24,
для её учёта можно завести отдельную переменную.

Попытайтесь решить эту задачу используя минимальное количество временных переменных и без условных переходов if.
Если вы найдёте формулу индексации, будет замечательно! Она может быть весьма витиеватой..

Советы и рекомендации
Результирующий массив должен выглядеть так:

0 1 2 3 4
9 8 7 6 5
10 11 12 13 14
19 18 17 16 15
20 21 22 23 24

Внешний и внутренний циклы идут от 0 до 5, тут ничего нового.
Первый индекс (строка) тоже без сюрпризов: это значение счётчика внешнего цикла:

for (int i = 0; i < 5; ++i) {
		for (int j = 0; j < 5; ++j) {
			digits[i][...] = number;
			number += 1;
		}
…
	}

Самое сложное тут — это номер столбца.
Чтобы сначала двигаться слева направо, а на следующей строке наоборот, стоит завести переменную-множитель,
которая на чётных строках будет равна 1. На нечётных строках меняет знак: multiplier *= −1;*/

#include <iostream>
#include <chrono>

//размерность матрицы
const int n = 5;

void display(int arr[][n]) {
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			std::cout << arr[i][j] << " ";
		}
		std::cout << std::endl;
	}
}

int main() {
	int A[n][n];


	//заполнение змейкой вариант с двумя циклами
	auto start = std::chrono::system_clock::now();
	int multiplier = 1;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			A[i][j] = 2.0f * (float)i;
			std::cout << A[i][n - (j * ((i % 2) * -1))] << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "Variant 1 - " << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start).count() << std::endl;
	display(A);

}